Welcome! In this series of short videos, we will look at topics for the PowerBasic Windows compiler. Today we will look at the use of OpenGL. That's the Open Graphics Library within your applications. Today we're going to be looking at the Open Graphics Library. OpenGL is a cross-language, cross-platform API for rendering 2D and 3D vector graphics. Although OpenGL is no longer in active development, there are extensions which can provide additional functionality. However, today we are just going to make use of the OpenGL32.dll that ships with Windows 10 and 11, by looking at a piece of software created by Gary Beene, to which I've added a couple of small additions. I'll put a link to Gary's website in the description below. This site contains lots of useful examples of PowerBasic code. As you can see on screen, we're going to be demonstrating the 10 primitives that OpenGL supports, from points all the way down to polygons. I have added more options at the end of the list, which we'll cover later in the video. What you can see at the moment is the use of the points. We have six points and we're rotating around these. If we switch to Lines, we can see we have two lines on the screen, one in red and one using a gradient fill. The next is Line Strip. This allows us to display a longer and more angular line. And the next is Line Loop, which is showing a closed, four-sided figure. If we now go to Triangles, we can demonstrate the use of gradient fills. Each corner of the triangle has a base RGB colour. Triangle Strip allows us to add triangles together. The next one is Triangle Fan. And as you can see, this takes the concept a little further. Again with a gradient fill. Quads takes us into the realm of four-sided figures. Quads Strip allows us to join these four-sided figures together, again here with a gradient fill. Next is Polygons. This allows you to specify the coordinates of each of the vertices of the polygon. The final four elements are not primitives. These are built up from the primitives themselves. First, we will have a look at the Wire Sphere. This allows us to specify quite easily on screen a sphere with a number of longitude and latitude lines. The sphere is formed up of quad strips, except for the north and south poles, which are triangle fans. We can specify a circle quite easily, and this one has a nice gradient fill. The next one is Spheres. In this case, it appears as if it's a billiard ball. We have incorporated lighting and shading on this one, to give quite a realistic rendition of a sphere. And the final one is Teapot. What would a 3D demonstration be without the traditional teapot shape? So we will next look at the Power Basic code that's been used to generate these images. So let's go and have a look at the code. So at the top of our code, we have listed the ten different primitives that OpenGL supports. Points, Lines, Polygons, Triangles, Quads, Line Strips, Line Loops, Triangle Strips, Triangle Fans and finally, Quad Strips. We're now including four libraries with this code – the standard Windows 32 API library and three additional ones, coming from José Roca. The GL include, the GLU include and the AFX GLUT include. I've added each of these libraries to the zip file to make it easy for you to test out this program. And I've created an enumeration for all of these primitives. We've also used a macro to define the constant pi. The dialog is quite straightforward. We're using option buttons. And the graphics are displayed actually on a label control called "id_Label". So the work begins in the callback function, the Event handler. In here, we're doing a number of things to set up. We're using two subroutines, first of all to get the render context and secondly, to initialize the scene. We'll cover these in a moment. Then we're setting up a timer, triggering every 50 milliseconds. This is to allow us to change your viewpoint of the 3D or 2D object. And when any of the option buttons are selected, we are calling a routine called "draw scene". Draw scene is the routine which will draw the image onto the screen. This is called from a number of places. As you can see from the timer and from the paint. This takes a number of parameters, either to have rotation or no rotation. So if we look first of all at the get_render_context subroutine. This is first of all setting up the pixel format properties for our device context. We're going for 24-bit for both the colour bits and for the depth. And this command here, "control handle", gets the handle of our label control and stores it in hLabel. hLabel is a global variable. And we're using the get_dc call to get the device context. And another Windows API call, setPixelFormat, to set our pixel format up and ready to render. Once this is done, we're into the initialize scene. And this is where we start using some of the OpenGL functions. To clear the colour, to set the depth, to specify the depth function, to enable depth test, to go for smooth shading and to go for the best quality rendering we can on our device. So if we have a look at the routine which does all the work. The one called draw scene. It takes in the three parameters, the X, Y and Z coordinates. And we're stepping through each of the possible selections the user has made. So we're basically checking to see which option button has been clicked on the screen. We're then clearing the buffers and we're going through a series of routines which I've done my best to document. As these are likely to be routines you have not used before. Once this is all set up, we're using a rotate call to work out the rotation of our coordinates, both the X, Y and the Z coordinates. And the main work begins in the case statement. This is testing the selection you have made from the options. If we're doing points, it's setting the vertex of each of these points. And it's held within a begin and an end command. And we give it the constant to see what kind of object we're dealing with, in this case points. The same with the lines, the line strip and the line loop. The triangles are slightly different, as in the triangles have different colours. So the first corner is green, the second is red and the final one is blue. And the same approach is taken with the triangle strip. We're using the glColor3ub function to specify the color for each of our vertices. And again, a similar approach taken with the triangle fan. With the quads, we're setting the default vertex color in one line, as green. And for the quads strip, the same approach again. So when we get to the circle, this one is slightly different. We're using the triangle fan and we're using a for next loop, going from 0 to 360. So this allows you to specify all 360 degrees. And we're using the glVertex2f with the radius and pi to draw the circle on the screen. The change in the color is used by manipulating three constants, one for red, one for green and one for blue. And using the color3ub function to set these. For each degree, we go around a circle. The solid sphere is slightly different. The solid sphere, we're using one of the functions within the library, which we've added at the beginning of the application. We're using the translate with the coordinates provided. And we're setting the three parameters using this function here. This single function will display on screen a solid sphere of this radius and the number of subdivisions you specify. And in this case, we're using 64 to give us the best chance of having a smooth looking sphere. The only additional things we're doing in this function is setting up the lighting and the material parameters. And once we pop this matrix, at the very end of this select statement is the command to swap the buffers. This will display the image to the user. With the teapot, we're using exactly the same approach when we're calling a different function in the FX library, the solid teapot. If we have a look at this library, you can see in the function list there are a number of functions you can call to get specific shapes very easily, from wire spheres to wire teapots. If we look inside this teapot function, you'll see there's a large amount of code to define the coordinates of each of the areas of the teapot. And this saves you doing a great deal of work. So if you're after a slightly more enhanced primitive, you can use these together. And looking at the code within these functions can give you ideas of how to create other types of objects. So feel free to browse into this code. So this has been a short dip into the world of OpenGL. Hopefully you found this code interesting and might find uses for it within your own applications. However, that's it for today. Thank you for watching.
