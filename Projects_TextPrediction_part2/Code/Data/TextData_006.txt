Welcome! In this series of videos we will cover the design and implementation of a project, from initial design through coding and development to testing using the PowerBasic Windows Compiler. Today we will continue our project to create our own web browser, by adding support for hyperlinks on text and other enhancements to the existing code. This was our application at the end of the last video. We have our experimental browser set up so we can display an index page. On our index page we have four graphics. Each of these graphics contains a hyperlink, allowing us to click on the hyperlink and go to a number of underlying pages. What we're going to add today is the ability to have a text hyperlink. I've prepared a second index page to demonstrate how this is going to be used. So in order to see what we're aiming for I'm going to use a chrome browser and we're going to drag this new index page onto that browser. And this is what we're after. The four links as we had before and a text link at the bottom, allowing us to go on to a fifth page. Also as you'll note on the chrome browser, when the mouse moves over one of the underlying hyperlinks, the mouse cursor changes from a pointer to a hand. Regardless of whether it's a graphic or a text hyperlink. We're also going to implement that functionality in our application. But before we do that we're going to fix one bug I've discovered in the existing code. If we go into say for example page four, page four contains text and a graphic. The graphic has no underlying hyperlink. Yet when we go on to the graphic and click on it, it's taking us to page one. The reason for this, as we go onto each page, it's automatically setting up the hot zones for each of these hyperlinks. Designating the x and y coordinates, which contain the zone, which when clicked on will trigger the hyperlink. These hot zones are not being cleared out when we move from one page to the next. So we go to page two and we click up near the top. It will go back to page one. So that's the first bug we need to fix. So let's have a look at our code. There is a function called render the HTML tags, which is triggered each time we load a new page. So this is where we're going to make the one line code change to fix this bug. So here we are now in the render the HTML tags function. So before we step through each of the tags within the HTML, we'll want to reset the contents of the global array, which contains the URLs. We can do this by using the reset command, followed by the name of the array we wish to reset. So if we try running our code now. There is our browser. And if we drag our index onto that and click on page four. And we click on the image it is now no longer linking back to page one. So we have cured the first bug. So let's drag index number two onto this browser and see how it looks. We will see that each of the graphical images is still appearing as normal. However, the text link at the bottom of the page going to a new page five is only appearing as text. This is because we're not handling this particular type of tag just yet. So we've now created a page five that this can actually link to when we get the link working. So let's go back to the code and make the changes to allow us to handle this particular type of text hyperlink. The render the HTML tags function is our engine to handle all HTML tagging. If we look further down on that, we'll see these are all the tags that it currently handles. We are handling the A and the closing A tags at the moment, but we're going to have to add some extra functionality to these to allow it to perform. First of all, we need to get the data inside the tag. As you can see from the index to HTML file, we have here the tag, which is referencing page five. The highlighted portion is already picked up and populated into the attributes variable. However, the go to page five is not currently picked up. But we have a function which can be used to pull that information back called get tag value, which is exactly what we're going to do. So the return from this function will return the text we want to display on screen. So here we need to differentiate between the graphical image, which is within this tag and the text which is within this tag. One easy way to do this is to look for the equals sign. If it contains an equals, then it is a graphical image we're attempting to show to the user. If it does not contain an equals, then it's not an image source, but plain text. So we can test for this by using the in string command. And we're going to set a variable to say image is false. This can be tested elsewhere in the code. Next thing to do is to reset our tag user defined type. So the reset command can reset this user defined type. We're incrementing the URL and we're storing the URL itself in our user defined type, as the URL was picked up previously in the code. So having got this far, we now need to print this text onto the graphical canvas. So as we have a function called print data whose job it is to perform this, we're going to call that. But we're going to change the existing print data command to accept additional parameters. We're going to pass ref tag and we're going to pass our user defined type. The ref tag is either going to be true or false. And the user defined type is going to be used to store the hot zone, which is the URL, just as we did for the graphical images. So let's go to the print data function and add these extra parameters. So here are the two extra parameters for this function, the ref tag variable and the user defined type. Print data is called from elsewhere in the application. So we're going to have to ensure that everywhere it's called, these two additional parameters are included. However, before we do that, I'm going to add on a couple of extra local variables. These I'm going to call image width and image height. We're creating these two variables to contain the width and the height of our text hyperlink. This information is needed as we need to store this information in the global array. So that when the user clicks on the graphics control, we know whether they've clicked on a hot zone, which will trigger a call to a hyperlink. So in order to do that, we'll need to change this line of code. This is looking to see whether our string coming in as image source equals within it. I'm going to change this so it's looking for a href equals. To tell whether it's an embedded image or a hyperlink. This allows us to set the global X and Y positions of the text. But before this section of code, we need to determine the height and width of the text. This is done by testing our ref tag. If the ref tag is true and the str data is not an empty length string, then we know it's a text URL. And we can work out the height and width of the text. We can do this quite easily by using a new command called graphics cell size. This gives us the height and width of a standard character in the selected font. This saves us having to work out which font we're currently using on the graphics control. And having worked out the width and height of a standard character, we can then multiply the width by the number of characters. And adding a little to the height just to make it slightly bigger. This gives us the values we can now store in our user defined type. Using the global X and Y as the top X and top Y. And adding on to that the width and height for the bottom X and bottom Y. If we try compiling that now. We can see we have one local variable we still have to declare, at the beginning of the render HTML tags function. So while we're adding this variable I'm going to add some more. We currently have a command variable that stores the current command. As some of these tags are going to be nested, we'll need to work out what the previous command was. So I'm going to create a local variable to keep track of the last command. And we'll also create a couple more boolean variables. One to keep track of the fact is it an image or not? And one to keep track of the fact are we inside a paragraph or not? This will give us more flexibility for the work we're doing today and for future changes. In this line of code we're picking up the current command. Before we populate this we'll want to populate the last command variable we have just created. Now that that is stored we can quite happily go ahead and populate the command variable. So as you can see we make other calls to the print data function. So we will need to amend each call to this print data function to add these extra parameters. Additionally in the paragraph section we're setting the paragraph boolean. To be true since we know at this point we are inside a paragraph. And here are our extra parameters to the print data function call. And we've now added the population of the in paragraph variable to false when we close off our paragraph. So our application is compiling quite happily now. So let's try running it and see how good it looks. So we drag in index 2. We can see we've now got go to page 5 at the bottom of the screen. However is it a hyperlink? If we click on it it's indeed taking us to page 5. So we've achieved the ability to have hyperlinks which go directly to the page regardless if they are images or text. However what we need to tackle next is we need to change the mouse cursor from an arrow to a hand when it goes over a hot zone. We already have a callback function which handles the mouse movement on the screen to pick up the left and right mouse clicks. This is the graph proc function. So within this function we are currently handling two events. The left mouse button going up and the right mouse button going up. So we're going to handle a new event in here. We're going to handle mouse move. This will trigger every time the mouse is actually moved. And we will create a new local variable to allow us to store the handle of the new cursor. And we'll call this hand. Here is a new mouse move event. This as we did with the previous events is picking up the x and y coordinates of the mouse. We're determining where the location on the graphical screen because it is a virtual graphical screen by adding on the width and height. And then we're using the existing function is link to determine whether the zone under the cursor is a hot zone containing a hyperlink. If that's the case we are checking to see if the hand handle is currently populated. If it's not populated we're then using the Windows API call load cursor to load our hand cursor. And using set cursor which is another Windows API call to set the cursor to that particular one. So we're now displaying index two. If we move the mouse around the screen it stays as the ordinary arrowed mouse pointer. If we move it over one of the zones it changes to a hand. And if we move it back it changes back to an arrow. As you will guess we are not putting any code in to change the mouse cursor back. Windows is doing this automatically for you. If we move the mouse down to where our text hyperlink is it changes to a hand as soon as we are over the hyperlink. So we have successfully implemented the ability to change the mouse cursor when we're over a hot zone that contains a hyperlink. One thing that we have not done yet is to change the text on our text hyperlink to a different color and mark it as underlined. This would normally indicate to the user that this is a text hyperlink. We won't do that in this video we'll do that in a future video. One other thing I'd like to do today to finish off with is to change the location of our graphical hyperlinks on screen. At the moment they are appearing one after the other vertically. If we go into our index HTML and make a minor change these are contained within paragraphs. So the page one and page two links appear below each other. If we take out these paragraph tags so that both hyperlinks are embedded in the same paragraph. If we save this and copy this back into our browser we'll see that it does no longer appear normally. If we looked at this file in a Chrome browser we will see they would appear quite normally. There is however a gap between each of these images which is quite odd as it has what appears to be a hyperlink for page one between the two. I would have expected both of these images to appear side by side with no gap. However what we need to do in our browser is to change it so they do indeed appear side by side. So we need to obviously handle the fact that it's possible to have these graphical images horizontally on one line. So back to the code. As you will remember earlier on we made some changes to the paragraph start and paragraph end tags. To set a variable called paragraph either to be true or false. We can use this to determine when we print an image on screen if we're still inside a paragraph or if the paragraph has moved on. And this is where we're going to make use of the last command. We can test to see if the last command was the closing a tag and if it's true we're currently working on an image. If that's the case then we can reset the global x coordinate to be 0 and the calculation of the y coordinate will involve the current value plus the bottom y minus the top y. And we can use the graphics set position command to set the location where the next printing will take place. So since we're now using this in paragraph variable we'll need to pass this to the function which displays the images. So this is an additional variable we're adding on to the list. And having passed this variable to this function we can test it within the function itself. And there is our function and we'll add on this extra parameter. And further down the function where we're updating the global position we can take out the graphics get position command as this is determined further up anyway. So this line of code is no longer needed. And we can now test the in paragraph tag. If the in paragraph tag is true then we can add on the width of our graphical image to the x coordinate. If it is false then we're resetting the x coordinate to 0. The y coordinate can be the y coordinate plus the height of our image. So with that logic in place let's try recompiling which recompiles quite cleanly. And we'll try running our application and we'll see if it now handles correctly the new index page. And there we have page one and page two appearing side by side. In our browser we have no space between the two images which to be honest I personally prefer. If we click on page one it takes us to page one. If we click on page two it will take us to page two. Page three still works. Page four and the link which is the text URL to page five also works. And our history is working fine. So in summary what we've done today we have enabled our browser to support text hyperlinks. We have also allowed the cursor on the mouse to change to a hand when it moves over the hyperlink either graphical or text. And additionally we can now have graphical hyperlinks side by side on the same line. There is of course a great deal more to do but we'll leave that for later videos. That's it for today. Thank you for watching.
