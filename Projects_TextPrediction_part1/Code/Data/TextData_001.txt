Welcome. In this series of short videos, we will look at topics for the Power Basic console compiler. Today we will look again at commands for the console. This was our application at the end of the last video. We have created a console application which displays information to the user on the console screen. As you will see from the start of the code, we have two lines of code at the beginning which define two constants, one for rows and one for columns. In the pb_main() function, we make a call to a prep screen function. This one here. This prepares our console for use. As you will see in here, we have a command which sets the size of the screen using the con virtual command. So currently we're set for 25 rows and 80 columns, which is the standard console size. The first thing we're going to do today is to increase the size of our console, to go up to 50 rows and 100 columns. If we run the application now without any further changes, we will see it displays quite happily, but you will also see we now have horizontal and vertical scroll bars, which allow us to move up, and down, and left and right on the console. This allows you to set a console up that better suits your application, giving you more flexibility for what you can use the console compiler for. The next thing we're going to change today is the section of code that displays information on the screen to the user. We have this at the moment inside a Do loop. This one here. We're going to take this section of code and move it into its own function, and we're going to call that function display screen. Having these lines of code in its own function will make our PB main function much tidier. And here is the new function with the code just pasted in. First, we clear our console screen, we display the headers, and we jump into the Do loop to display the data on screen. If we run the application now, we will see it behaves exactly as it did before. It runs through the loop, and at the end of the loop, it will terminate the application. Since we have removed that code from our PB main function, there are some declares at the beginning of the function that we no longer need, so we will just take those out. Next, we're going to make use of one of the features of the console within Power Basic. Within Power Basic, you have not one, but eight consoles available, and we can switch quite easily between each console. Only one console can display to the user on screen at any one time, but having these eight separate consoles gives us a great deal of flexibility for how our application operates. In the display screen section, there's a call to a underlying function called display headers. This displays basically a template on screen, which we can use later on. These are the headings. Within Power Basic, the console compiler keeps track of both the active console page and the visible console page. It's important to differentiate between these two. The active page is the page that your commands will write to and read from. The visible page is the page that is visible to the user. And as you can guess, the visible page does not necessarily have to be the same as the active page. So within this function, we're going to set up two local variables, one to keep track of the active page and one to keep track of the visible page for our console. And I'm going to add another local variable called status. This is going to be a static variable. I intend to use one of the console pages as a template so that when the application runs, it will create a template on the eighth console page. That will be used as a template to copy into any of the other pages we wish to use. Therefore, you only have to create this template once. And a single line of code can be used to copy that eighth console page to any other page of the console. And our status variable is going to be used to determine whether we have or haven't yet created that template. So we're going to make use of two additional console commands. Con page active, which can be used to determine what is the active page, and con page visible to determine which is the page that is visible to the user. These will populate these two variables, which we can then test. Testing the value within our status variable will determine whether the template has already been created or not. If the template has already been created, we're going to use a con pcopy command. This will copy from one console window to another. And I'm going to create a new constant in a moment to hold the value 8. That will be template page. So with this single line of code, we are copying the eighth console to the currently active console page. And in order to determine which console page we're actually on, let's print something to the screen so the user can quite easily see which console page is in use. So we will set the location to print to row 1, column 2, and we'll call the print function we created in the last video. This to print the visible page number to the top of the page, in the cyan colour. And once that has completed, we can then exit the function. If the status variable is false, it means our template has not yet been created. So we can use the code that's about to follow this to create our standard template. So we will set the status variable to the value true. And all the code after that we need not change. This will print to whatever the active console page actually is. So at the end of this function, we will copy the active page back to the template. Before we run an application, we'll need to create this new constant, this template page constant at the beginning of our application. And we'll set that to the value 8. So we'll be using the eighth console page as our template. So with the page number now displayed at the beginning of our console page, we can now try running an application to see how it performs. And there we have page 1 at the top of the screen. So now that we have this multiple console ability set up within our application, how can we make use of it? So let's go back to our pb_main function. In our pb_main function, we prepare the screen and we display the screen to the user. Next, what we're going to do is we're going to make use of the con scroll commands. This allows you to scroll up, down, left and right on the console. Scrolling up on the console will move the text effectively downwards. So I will put a waitkey command after that so we can still see it on the screen after the application completes that command. We display the information to the user and once that's complete, the console scrolls down by 10 rows. This allows you to move information around on the console, effectively creating a blank area to which you can then write. Even if that area is above information already committed to the console. So we're going to get a little interactive with the console here. I'm going to create three new local variables. One for input, one for page, both string and number. And we're going to be using a Do loop here. So we will first position the cursor at row 2, column 2. We will set the colour to black with a white background. And we will use the con input command to prompt the user for a response. So giving the text, do you wish to exit yes or no? And whatever the user types and then presses enter, we will store into the input variable. This allows you to get interactive with your user. We can then test the value of that input variable. I'm forcing the input variable to uppercase to test to see if the word yes has been given. If it has, we're then exiting our loop. If we're not exiting the loop, I'm going to ask the user to select which page of the console they actually wish. And we'll limit the user to either page 1 or page 2. Again using the con input command to prompt them for an input. And we'll store that in a string variable called page. We can then transfer the value in that string variable to a numeric variable using the VAL command. And we're then testing the value of that page variable to see if it's either value 1 or 2. We're then setting the visible and the active pages using the con page visible and con page active commands. While we're setting both the visible and the active consoles to the same value, you can use these functions to set them to different values if you have different functionality in mind. Now that we've prompted a user for another console number, we can then re-display the screen to the user using our existing display screen function. We're resetting the color back to green with a black background and calling display screen. And then scrolling up 10 lines, as we did earlier. So once we exit this loop, we can then, for the purposes of this application, re-display each of the console pages to the user. For example pages 1 and pages 2. In order to do this, all I need to do is to use the con page visible command to set it to the page I wish. And then we're using a waitkey command to allow it to remain on screen so we can see it before going to the next console page. So let's try running our application now and see how it goes. So the application runs and we're displaying the information on page 1 to the user. Once this is completed, we scroll down 10 lines and we prompt the user to see whether they wish to exit yes or no. So in this case, let's put the value no in and press the enter button. It's now asking which console page we actually want. We know we're on console page 1, so let's pick console page 2. And it's now displaying console page 2 to the user. And once this has completed, it will again scroll down another 10 lines and ask if you wish to exit yes or no. In this case, we'll say yes. What it has now done is it's re-displayed to us what was on page 1, as you can see from the screen. The last data appearing on page 1 is now visible, including the two prompts at the top of the console page. We're now sitting on the wait key command. If we press the enter button, it will now show us what was in page 2. And if we hit the enter button once more, the application will complete. So in summary, what we've done today is we have extended our console beyond the allowing us to have scroll bars, vertical and horizontal. Additionally, we have taken information on our console screen and saved it to a template console screen. And as the console has 8 screens within Power Basic, we can use these quite easily to switch between them, using the visible and active commands. We have displayed information on the first page to the user and asked them whether they wish to continue. If they say yes, we're allowing them to pick another console page. And once this has been completed, when the user decides they wish to exit, then we're showing each page to the user. The ability to have 8 console pages and to allow the user to switch between them, and also to copy information from one to the other, gives you a great deal of flexibility in your console applications. Hopefully you'll find this useful in your own applications, but that's it for today. Thank you for watching.
