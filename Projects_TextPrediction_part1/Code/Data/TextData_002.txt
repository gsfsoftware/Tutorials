Welcome! In this series of videos we will cover the design and implementation of a project, from initial design through coding and development to testing, using the Power Basic Windows Compiler. Today we will continue our project to create our own web browser, by completing the work on text hyperlinks and adding support for the underline tag. This was our project at the end of the last video. We have a light browser which allows us to drag HTML pages onto the browser. This then displays our HTML page to the user, and if we click on any one of the image hyperlinks, it will take us in to the next page, including the display of graphics. We also have headers and text which is paragraphed, and we have a text URL at the bottom of our index page. However, at the moment this text URL is not underlined, which is more or less the standard for all text URLs. That's what we're going to tackle today, is the underlining of text hyperlinks and the use of the underline tag. The underline tag in HTML can be used to mark a section of text as being underlined. However, the use of the underline tag is usually discouraged, as it can confuse users to think that a piece of text is underlined is a hyperlink. However, it's still supported within HTML, so let's go and have a look at our code to see what we can do to achieve this. Currently, we have two globals at the beginning of our code, one for the default font and one to contain the handles for the array of fonts we are using. We're going to add two more globals to this list, one for the default underline font and one for an array of underline fonts. This will allow us to maintain an array of underline fonts, which we can use at any point in the application. So, as you can probably guess, we're going to have to create and also destroy fonts when the program starts and when the program ends. So, we have two functions which perform these functions, one called create fonts and one called unload fonts. So, let's go to the create fonts function first. In here, we are re-dimensioning our array as having six elements. We're going to add a command to do the same for our underline fonts. It allows us to store the handles for each font. So, as we have six normal fonts, we're going to have six fonts of the same size, but set for underline. So, we've added a font new command to create our default font, which in this case is set for option five, which will allow us to have bold underline. And in our for next loop, where we created the six fonts, we're creating six additional fonts, but this time set with the underline flag. So, now that we've created our fonts, we also have to unload the fonts when the application completes. So, if we have a look at the unload fonts function, it will quite simply need two font end commands, one to end the default font and one to end each of the fonts referenced in our global array. So, now we need to handle the underline tag when we get to the render the HTML tags. This is our tagging engine. So, let's go to that function and make the necessary changes. At the end of our select statement, we're going to put two more case statements in, one to handle the beginning underline tag and one to handle the end of the underline tag. So, if we are starting an underline section of the HTML document, we need to set our graphic font to the default underline font. And we can do that using the graphic set font command, using our global variable for the underline bold handle. Next, we can pick up the data after the underline tag by using the function we created in our previous video, the get tag value, giving the long start variable and the underline end tag. And then we can go to the print data statement, which will print our data to the screen. And with the end underline tag, we can reset the font back to the global handle of the default font. So, in order to test to see how far we've got with the underline tag, we need to make a change to one of our web pages. So, we're going to amend the index to HTML document. So, beneath the section which is going to be hyperlinked, we have a new paragraph, which is a test for our underline. So, we have the word "test" and a piece of text after that, which is not going to be underlined. So, let's run our application and copy in this HTML document. So, we have partially achieved our objective. We do have the word "test" marked "underlined". However, the tag is still visible on the screen to the user, and we don't have the words "and not underlined" after the underlined "test" text. So, there is more to do. We'll need now to have a look at the print function, which prints data to our graphics control. So, let's go back to the code. So, within this function, we handle all the text that has to be printed on the HTML page for the user, and our underlined tags are, in fact, embedded links. So, we have a section of this code which currently handles embedded links. We'll need to expand on that. Here is a section of code that tests for an embedded link. So, we're currently looking for the href equals text to determine whether this is a URL, and if so, we are setting positions and exiting the function, so we do not actually print that data. And now, we're also testing for the underlined tag. If it's an embedded underlined tag, we're exiting the function, so we do not print. So, let's try running it again and see what we get this time. And now it's looking slightly better. We're getting the word "test" underlined, but we're missing the text after that. So, there's a little more to do, but at least we're no longer getting the underlined tags printed on the dialog. So again, back to our code. Sometimes, when you're developing applications, you'll find you may have to go through a great number of iterations to edge towards the eventual application that you wish to use. This is quite normal in development when you're working on something you've never done before. So, while we're in this function, we're going to add the color and the underline to our hyperlinks. If the ref tag is true and our strDataViable is populated, then we know this is a hot zone. This is going to be a URL. So, all we really need to do is to add color to the foreground and background of our font and set the font to be underlined. So, with our simple two commands, we should have now handled the underlining of our hyperlinks. So, let's try running it again and see if we've achieved that. Well, there we do have a go-to page 5, which if we click on it, will take us to page 5. So, we've achieved the coloring and the underlining of a text hyperlink. So, you can now see the confusion that using the underline tag can give to a user. We have two pieces of text, one saying go to page 5, which is indeed a hyperlink. As we can see, if we move the mouse over, it changes to the hand symbol. But the word "test", which is also underlined, is not a hyperlink. But to a user, it could give the illusion that it is a hyperlink. So, generally, the use of the underline tag is now discouraged. The one piece of functionality we still have to have on the screen is to have the text after the ending of the underline tag. As you will see, we have the words "and not underlined", which follows the word "test". So, let's go back to the code to see if we can tidy that up. At the end of this function, there is a piece of code which handles where there is a piece of text with no line breaks. We need to check in this section to see whether this is a reference tag. And if it is true a reference tag, we need to reset the default font and color. This is done quite easily using these two commands again. The graphic color command to set the foreground back to black and the background to white. And to set the font back to the default font. So, there are a couple more changes we'll need to make to this code to fully support the underline tag. When we get to the end of the underline, we need to check to see if we're actually inside a paragraph or not. We can do this by testing the "inParagraph" variable. If that's true, then we are indeed inside a paragraph. So, there may well be some text still to print. So, we can pick that up using the "getTag" value, looking for the end of the paragraph tag. And then calling the "printData" function to print that out. So, let's try running that now to see if we've got our extra text now. Well, we're edging closer. We do actually have the extra text, but it's on the next line down. Therefore, it's treating the text after the underline "endingTag" as a new line of data. So, let's go back to the code and sort that out. If we have a look at the "printData" function, we'll see there's a graphic print statement which is doing two things. It's trimming the data, which will mean taking the leading spaces off the end of the string, which we do not in fact want. And it's also missing a semicolon in the end. A semicolon in the end means we will not automatically move down to the next line. So, that should in theory fix this problem. Well, it has fixed one problem, but it has actually introduced another one. It's not picking up the start of paragraphs. So, we'll need to go back to the code and fix that. So, we're going to create a new function which we can call from different parts of the application. We'll call this function "printBlankLine" and its job will be to move the text down to the next available line. So, here is our new "printBlankData" function. It has always three commands â€“ one to set the position of the x and y global coordinates, one to print a line with nothing in it, and a second to get the new position. We'll need to call this new function from within the "renderHTMLTags" function. And we're now going to look for the end of the paragraph. And there we have the call to our new function to print a blank line. So, have we now done enough to make our HTML document properly shown on screen? If we bring in our index2 document, and we can see that the problem we had with the underline tag has now been resolved. We have the link to go to page 5, we have the underline text which is "test", and the remainder of the line is showing as not being underlined. And we still have operational links to each of the pages. So, it's always a good idea to compare our browser with a standard browser. So, if we double-click on our index2 document and bring up a Chrome browser, and if we compare that with our browser, we'll see we're fairly close. We're missing an extra line at the end of each of the sections of text where the paragraphs are, but apart from that, we're fairly close. So, the solution for our problem printing seems to have been caused by this graphics print statement. While this is actually putting the cursor down to the next available line, it's not resetting the global coordinates for X and Y. So, we're going to take this line of code out completely, and I've put an additional print-blind line up here. This is a section which handles text which is not an image. So, if we try running an application now, hopefully this should fix the problem. And indeed, we do have the paragraphs quite correctly for the text, and we appear to have it for the images as well. If we compare that against a standard browser, we can see our text is appearing more or less exactly where it should. We have each of the images which have embedded links. We have the URL, which is a text URL, and we have underline and non-underline text within the same paragraph. So, in summary, what we've done today is we have added support for the underline tag. Additionally, we have amended the text URLs to be displayed in blue and with an underline, making it more obvious to the user that this is indeed a URL. So, obviously there is a great deal more to do in our browser. However, the purpose of this project is to cover areas of Power Basic that we may never have covered before, allowing us to pick up new skills. But, that's it for today. Thank you for watching.
