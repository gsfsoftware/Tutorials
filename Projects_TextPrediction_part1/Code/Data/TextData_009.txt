Welcome! In this series of videos we will cover the design and implementation of a project, from initial design through coding and development to testing, using the Power Basic Windows compiler. Today we will continue our project to create our own web browser by adding support for hyperlinks on images. Hypertext Marker Language (HTML) was developed in 1989 at CERN, the European organisation of nuclear research. Its purpose was not only to provide a common file format to share knowledge, but also to allow those files to have the ability to link to other files. This could be on distant servers. This was no small feat as they also needed to create the Hypertext Transfer Protocol (HTTP) - this to standardise communication between computers and the world wide web was born. The work in our light browser so far has been to support a number of tags within the HTML document. Today we'll be adding support for the Anchor tag to allow hypertext linking to other documents by allowing users to click on images. So what changes do we need to make to a code to support this new Anchor tag? The first thing we will look at is when the HTML code is loaded into our light browser. So what do we need to do to keep track of these new Anchor tags? As we're going to be clicking on images, we need to keep track of how much space these images take up on screen. These zones need to be stored within the application so that when the user clicks with the left mouse button anywhere on the graphics control we can determine whether the user has indeed clicked on an image which has an underlying Anchor linking it to another document. So we're going to create a user defined type called Image Tag. This will store the top left hand and bottom right hand corners of any of these linked zones and we will create a global array to store this information. So here is our new type called udt image tag. This has a number of elements. It stores an x and y coordinate for the top left hand corner of the image. It also stores the bottom right hand corner of that image. This will allow us to define the area of our clicking zone and additionally it stores a URL. This is the URL that once the user clicks on this zone we will link to and we have dimensioned a global array called URLs. This is an array of this user defined type. So having this global array our next question is how many elements are we going to allow in this array? How many zones are we going to allow the user to click on? So we've added a new constant called max URLs. We are currently setting this as 100. This will allow up to 100 links within our HTML document. Should you find 100 links is too small you can always increase the value of the constant and within our pb_main function we can dimension this array. So there we have our global array of URLs dimensioned for the maximum number. So now that we have somewhere to store the information we next need to pick the information up from the HTML file. So in order to see what we need to do let's launch the browser as it currently stands and we're going to drag our index document into that browser and as you will see we have the four images quite happily showing and we're not currently handling the anchor tag. So our first task is to handle the anchor tag when the document is read. So we need to make a change to the render HTML tags function to add support for anchor tags. So here is our render HTML tags function. This is the heart of our render engine handling each of the tags. So the last tag in our list currently is the image tag which is testing to ensure we're inside the body of the document before we display the image. So let's first put a couple of case statements in to handle the beginning and the end of the anchor tags. So here are the two new tags the beginning of the anchor tag and the end of the anchor tag. We're going to set a new variable within here called ref tag which will be true at the beginning of a tag and false at the end. This will let our code know that we're inside an anchor tag group and as we're handling clicks on images today we can test that within the image tag section. By testing this immediately after we display the image on the browser. So since the value of ref tag is true we know we're inside a reference tag. We're within the block which is the anchor. So we need to store the link which has come in on the URL. So at this point we need to have already stored the value in the URL variable and we can do that quite easily at the start of the reference tag because the URL will be within the attributes. So we're looking specifically for the equal sign and we're taking the second part of that using our parse command and trimming off any double quotes. So for the moment this should give us the direct path, albeit in the same directory, to the file we wish to link to. So as the anchor tag is processed before the image tag then at this point in the code our strURL variable will be populated. So where are we going to populate the details of this image? The display image command is the one that loads the image up from file. So we're going to pass a user defined type to that to allow us to pass back the x and y coordinates of the top left and the bottom right hand corners of the rectangle. So we're going to use a new local variable which is a user defined type we declared at the beginning of our application. This will be a local variable to this function. So let's go to the beginning of the function and declare the local variables we're going to be needing to do all this. So here are our new variables. We're using the ref tag as a true or false to determine whether we're inside an anchor tag or not and we're using a user defined type to store the coordinates top left and bottom right of the image. We're using url to store the url in the link and we're using another variable which is a long as the last populated url. As the user will have up to 10 tabs usable within the browser and we load each one up dynamically each time the user clicks on a tab. Therefore we need to keep track of a number of these URLs as the user can step back and forward through 10 history pages for a tab only to hold information for each of these URLs. So as well as resetting this tag we need to pass this value to our display image as it will populate this with x and y coordinates. So before we amend this display image function let's push on and put the rest of the code in here. If ref tag is true then we're inside a anchor. The url has already been populated so we need to increment the pointer to our url position. This will determine the place in the urls array. Now we can populate the link from the url variable. Inside our user defined type and then we can quite easily slot this entire user defined type into the array of user defined types based on the url long variable. So next we need to go to the display image function. As we have changed the number of parameters it's now accepting. Up until now it's taken only three parameters the dialog handle the attribute string and the tab that has been selected. Now we're passing an additional value which is a user defined type. So further down this code we have loaded the image file from disk into memory and we have the image width and the image height which are the key bits of information we need to store in our user defined type. So after our copy command we can store the location. I'm using the prefix command to prefix the name of our user defined type before each of the elements. We're storing the x and the y coordinates using our global x and y. We're storing the bottom right hand corner by taking the global and adding on the width of that image and the bottom y coordinate is the global y coordinate plus the height of the image. So we have now stored the x and y location of both the top and left and the bottom right hand corners of our image and this is passed back to the calling routine to be passed into the global array. So now that we've stored that information in a global array how can we make use of it so that when the user hovers over it when they click with the left mouse button it will load up the URL that's been stored in the array. Well we've already got a function which allows us to right click on the graphics control we merely need to add to that the ability to trap left clicks as well and that is within the graphic proc function. So here is our graphic proc function. This is a function which is called when the user clicks either with the left or the right mouse button. We have a condition set up to handle the right mouse button at the moment. We now need to add a condition for the left mouse button. So here is the case statement to handle when the user clicks with the left mouse button. When that button is released we will pick up the x and y coordinates on screen. We will populate the URL with an empty length string and at the moment we will display a message box on the screen to prove that we've actually trapped the left mouse button. So let's try running the application now and if we left mouse click someone on the screen we're getting the message box. So we are correctly picking up the click with the left mouse button. So we've proved that works quite successfully. So next we have to create a new function called isLink. This will take three parameters the x the y coordinate and the URL. The URL is going to be populated on return from that function if the zone we have clicked upon is one of those which has an embedded link. So let's go and create this new function. So as I said this function is going to take the three parameters the x the y coordinate and the return value which will be a URL. So we're going to use a for next loop here to step through each element of the global URLs array. So this is quite a simple function. So for each element of this global array we're testing the x and y coordinates against the values stored within. If the x coordinate is greater than the top x but less than the bottom x and the y coordinate is greater than the top y and less than the bottom y. If this is all true then we are indeed within a zone which holds a link. We can then populate the URL from that by using the trim command to trim it down from the extra spaces at the end. We can then return the value true and exit the function immediately. If we find no entry within this array then the value returned is false. So this will give us a mechanism by which when the user clicks on the graphics control we can determine if the area they have clicked on has been stored as an anchor hyperlink. So if this does return true what do we do next? Well we need to link to the new URL. So let's create a new function which can do that for us and we'll call that function process a URL. So here is the skeleton of our new function process a URL taking its single parameter which is the URL itself. Within this function we're going to be using some common code we have already created. So our first task is to determine the existing path of the URL we're currently on. We can get that from the URL text box which is on screen at the top of the dialog. Eventually we're going to have to support documents which are on a web server as opposed to those which are local to the machine we are currently running on. So this code will go through a number of iterations as we move down that path but for the moment we're going to take the value that's in the URL at the top of the dialog and we're going to work out is the path relative to where the existing URL actually is. So we're looking for the backslash and forward slash within the URL variable and we can determine the delimiter either backslash or forward slash depending whether we're actually pulling any local file or we're taking this from somewhere on the world wide web and as we're handling everything locally we're taking the last element of the end of the path replacing that with the file we've just loaded up the URL and we're launching from there. So we're using an inbuilt function in our file handling routines library which is called start range parse. This takes the path the delimiter and the end element. We have determined the end element using the parse count value. This counts the number of elements using the delimiter and subtracts one and we end up with a path which is the path to the folder but not the file itself. We then add on the file we've got from the URL and in later videos we'll put code in to handle these new paths. So now that we've got this far we now need to go through a series of steps to actually set values on the dialogue and to handle the population of our graphics control. So we are first going to call the clear graphics control routine and then set the text at the top of the dialogue to be the URL we're about to link to. We can then store the URL in our global array by determining the tab the user has currently selected and using that to store it in the array. And our final stage is to increment the latest slot array and then store the URL history and then finally render the HTML itself using our existing function setup to perform that task. So these are routines we've created in previous videos. So now that we've got this far how close is our code to completion? Let's try running it. Well there is our browser. Let's try dragging in our index document. Well our index document is showing but we've still got the text for the href on the screen. If we go over page one and click on it we are indeed getting a link to page one. If we go to page two we're getting page two. However we need to get rid of this text on the screen. Let's go back to the code and have a look at what prints on this graphics control. So printing to the graphics control of plain text is done in a function called print data. This determines the position to print and prints text using the graphics print command. And we are storing the value of the data to print in this temporary variable. However if this temporary variable contains an image source command then it's an embedded image. So we need to test and bypass that if that's the case. So here is our test for the embedded link. We're using the in string command to look for image source. As the value within temp data is all lowercase then this will work quite successfully. And if the value is greater than zero then it's an embedded image. So we can pick up the position we are on screen. We can print a blank line and we can then repopulate the global x and y coordinates. So let's try running that code once more. We drag in our index page and we are now missing the text we had before. But the links will still work. And we can have a look at the history and we'll see we have our index page and page two. So all appears to be working quite well. Page one gives us page one, page two gives us page two, and page three gives us page three. If however we scroll down the virtual graphics control and click on page four it's not giving us a page. Or is it? If we scroll back up we'll see we have indeed got page one. So why have we got page one when we actually clicked on page four? The reason for this is the graphics control is virtual. As we scroll up and down the position has actually changed. So what has returned when we click? Are they coordinates? Is it are the coordinates on the top left hand corner of the current part of the window? So if we click on page two it's going to give us page one because that's where page one existed. So we need to find a way of handling when the user has actually scrolled down to a lower part of the graphics page. So let's go back to the code and fix that problem. So when the user actually clicks on the left mouse button we need to make a change to the graphic proc function. In here we're picking up the x and the y coordinates but we're using a virtual window. So we need to get the beginning of this window and Power Basic provides a graphic get view command and this allows us to pick up a width and the height of where we currently are and we can then add that on to the x and y coordinates. So we've now started to use two new variables which we'll need to create at the beginning of our function as we have now done. So this should allow us to correctly pick up where we are actually clicking on and get coordinate system we can actually use with a global array. So let's try running the code once more. We drag in our index, we can click on page one, we can click on page three and if we scroll down if we click on page four it has indeed got page four. However the position on that screen is further down so we'll need to set the location back to the beginning of the page. So there's one more change we have to make. However the ability to click on each of the pages is working quite nicely. So once more back to the code. So there are several places within the code we could probably put this change. However the render the html function is where all information is rendered to the graphics control. So it's the logical place to put this single line of code. This is where we set up details for the graphics control. We do a clear command, we set the colors, we set the phone, we set the position. So we're going to enter a new line of code in here and that's to use the graphic set view command. This will set the view to 00 which is the top left hand coordinates of our graphics control. So if we try running the code once more, bring in our index page, scroll down, select page four and go back. We're now going back to the beginning of the page which is ideal. So we can link to each of the pages quite successfully regardless of the size of our browser. We can make our browser larger to accommodate all four links and we can link quite easily between each of the pages. And if we click on an area outside the click zones, nothing happens. We need to be inside the zone which we have trapped the coordinates of in order to make the anchor link work correctly. So in summary what we've achieved today is we have added a new html command, the anchor tag. This allows us to wrap around the image tag and make the image a clickable link. The user when they click on this image can then link to the image and then link to another document. So using this technique we can actually connect together a large number of documents and as we are supporting up to 100 links within any one html file this gives you a great deal of flexibility. There is of course a great deal more to be done with anchors and links in general. However we'll leave that for a later video. That's it for today, thank you for watching.
