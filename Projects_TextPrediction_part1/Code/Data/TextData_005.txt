Welcome. In this series of short videos we will look at topics for the PowerBasic console compiler. Today we will look at commands for the console itself. Today we're going to be looking specifically at commands used within the PowerBasic console compiler. And the commands we're going to be looking at are those directly associated with the console itself. There may come a time when you wish to monitor a background application. This would be a console application which is running with no user interaction. This process can be processing data into a database, processing many transactions or dealing with large file processing. As such you may want a quick and easy way to monitor what the application is doing. Something simpler than monitoring log files. So let's have a look at our code to see what we can do within the console itself. The Windows console can be quite flexible. What we're going to do first of all is to designate the number of rows and columns that are going to be used within the console itself. So I'm going to set up two constants, one for rows and one for columns. So in our console we're going to have 25 rows and 80 columns. The console can be set up within PowerBasic as a virtual console. Hence you can have more rows and more columns than console would normally show. Also within the console you can have a range of colours. There are only 16 colours available within the basic console and each of those colours is allocated by using a number. So to make our code a little easier to read, we're going to set up a global string which will contain the text of each of these colours. For example red, blue or green. And when we want to designate a colour we can use the text of that colour and the program will convert this to the number to be used in the console commands. And we'll call this global array "colours". So we need to do some preparatory work to set up our application, to use these colours and to prep our screen. And as we're going to be displaying some random data on the screen, just for the purposes of this video we're going to use the randomise command to set up the random number generator. So we have dimensioned our global array of colours to be 15 elements. That's starting from 0 and going to 15, which will encapsulate all 16 colours that we can use in the basic console. And we're going to be calling a function called "prepcolours". This will set up our colours in the array. So we will prepare that function now. This is a very simple function with effectively only one line of code. We're using the array's "sign" command to assign a value to each of the elements of our global array. Ranging from black all the way through to intense white. So having prepared our array with colours, we now need to prepare the console screen. So we'll create a new function to perform that. So we're passing a single parameter to this new "prepscreen" function. And this is the name we want on the console window itself. So let's create the function to prepare our screen. And here is our "prepscreen" function taking its single parameter, which will be the console name of the window. Our first task is to set the location of the console window on the monitor screen. Using pixel coordinates from the top left hand corner. And we're using the "con.loc" command to set the x and y coordinates. In this case we're going for 50, 50. Next we're going to use the virtual option to set the number of rows and columns on our console window. This allows you, should you need a larger console window, to set it quite easily using this command. And we're using the two constants we created earlier for rows and columns. Next we can set the title quite easy using the "caption" command. This will put a caption on the window of the console. Next I'm going to use the "color" command to set the default foreground and background colors. As you may remember the colors use numbers rather than names. Color 10 is green. There are two parameters on this command. The first parameter is the foreground color, which we're setting as green. The second parameter is the background color. If you use a -1 it will leave the value to whatever it is currently set at. Console windows default to a black background. So if we put a "wait" command in our pb_main function to allow us to run the application and have it display on screen long enough for us to actually see what it looks like. If we run the application now, we'll see our console window appears. It's got "monitor display" as the title of the window and if we press the button on the keyboard, the screen will close. So we have successfully set up our console window. Should you need to clear the screen at any point in your application, you can use the "cls" command, which is one of the console commands, to clear the console window completely. As we want to use this application to display some information to a user, there may well be some headers or default data to appear on this type of form. So we're going to create a function whose job it will be to display these headers. This will be text, which is non-changing. So we're going to create a display headers function to allow us to do this. So here is our function. I'm setting up three local variables. One for row, one for column, both numbers, as long, and one for text, which will be the text we want to print onto the console window. We're going to be doing a fair bit of printing to the console window, so I'm going to create a common function whose job it will be to print information to that window. But first we want to set the location to which we wish to print. This is counted from the top left hand corner of our window, so we're setting to row two and column two. And I want to print to this window a piece of text that says "Monitor System" and I want that printed in red. So we're passing information to the print function. Via four parameters, the row and the column, the text we wish to print, and the colour we wish to print it. So let's now go and create this print to console function. As you will see we have the four parameters being passed to this function. The last parameter is set as optional. My idea behind this is if you do not specify the colour, it will not change the colour. So we're going to put a piece of code in to test to see whether this optional parameter is present or not. So we're going to use the inbuilt is missing function. This tests whether the optional parameter has actually been given or not. So if is missing is false, then we know that a colour parameter has been given. And we want to get the colour number associated with that colour name. So I'm going to have a little embedded function in here called get colour. And this will return the colour number that the colour command needs to use for our foreground colour. And we're leaving our background colour as minus one. For this particular application I'm leaving the background colour as black. We'll create the get colour function in a moment, but let's push on to do the last couple lines of code in this function. Having set the colour should the parameter have come in, we want next to do the setting of the location to print to. And we can use the cell command for that, as we have the row and the column numbers. So now that we've set the location we wish to print to, we can then use the print command to print our text to the console. In this case the print command is followed by the variable containing the text you wish to print. And if you put a semicolon at the end of the line, it means it will not put a carriage return line feed at the end of the text. Which would automatically push the cursor down to the next row. This allows us to update specific locations on the screen without injecting an extra line. So let's go and create this embedded get colour function. So this is going to be a fairly straightforward function whose job it will be to return the number of the associated colour name. So as we have all of these colour names in a global array, we merely have to do a for-next loop to step through each element while looking for a match. So we're going for the zero element to the upper bounding of the array. The UBOUND command will quite easily return the maximum number of elements in this particular array, which in this case is 15. And we're comparing the colour that come in with the parameters against the colour held in the array. And we're using the U CASE command to force both of these strings to uppercase. This avoids having a problem where the user has actually coded this with lowercase for the name of the colour and our array is holding it in mixcase. Should this comparison return true, then we're returning the element number of the array, which is the colour number, and we can exit the function at that point. So let's try running our application now to see if we get the first line of text. And there is our first piece of text on our console. The words monitor system and it's printed in red. So now that we have the basic mechanics in our display headers function to operate, we can put additional pieces of information in to put text on the screen. These will be additional pieces of text which will not change during the run of the application. So the first of these is the word polling. This will be a section of the screen to indicate whether polling is active or inactive. And we're setting the row number to be row number 4 and the column number to be column number 2. And we're displaying this in green text. If we put another 2 in, the first saying server stats on row 6 column 2 and the next set of text we're putting on is going to be 3 sections all in one row. Displaying on row 8 starting at column 2. If we run our application now we can see how this looks. So we can see on screen we've got monitor system, the word polling and then server stats in a different color and then CPU load, CPU response time and user count. These are all the fixed pieces of text that will not change within our for next loop which we're about to do. So I'm adding a number of local variables to keep track of the row, the column, the text and a count variable. I'm going to use the count variable for the number of times we run round this loop. Each time we pass through this loop we will increment the count variable. Once the count variable reaches This means we will no longer need the wait key at the end of the application. So we can now start to put the information on the screen that the user would want to see. So we're going to populate first of all the system polling and we'll create a little function to return that value. These functions of course are just dummy functions. If you were writing this for real each of these functions would perform whatever is needed to get the information that you wish to display to the user. So this again is a very simple function just to demonstrate different text appearing on the screen. We're using the random number generator here to generate a number either of a 1 or a 2. If it's a 1 we will return the word active. If it's a 2 we will return the word inactive. It's important when you're using this on the console that the strings you put in within this loop are of the same length. If we put the word inactive in first and then in the next loop we put the word active in. Since the string active is shorter than inactive it would not overwrite the last two letters of inactive. But if we make them all the same length that will not be a problem. And to simulate what we'd be doing in a live situation we're going to put a sleep command in here. Otherwise the loop will run so fast you'll hardly see anything on the screen. So we're putting a sleep command in for of one and a half seconds for each loop. If we run the application now we'll see it displays inactive and active randomly. And then after 10 iterations of the loop the program will terminate. Like so. So we go back to the pb_main function and we can put some more printing in. Again specifying the row and the column that the text is to go into. And we'll reduce the delay down slightly. And run once more. Now we're getting the CPU load, again as a random number, in this case between the values 60 and 85. And as we're displaying this in white it's quite easy to discern on the screen. So we'll put two more pieces of information on our screen. And these are the additional bits of information also appearing on row 8 but further along in the columns. Again using the random number generator to go from a number between 30 and 80 and displaying this on the screen. As the numbers here are both going to be two characters it won't cause a problem. But in this bottom one where we're doing a random number between 10 and 2250 these will be turned different lengths in the string. So I'm using the RSET$ command to right justify the text and it's going to be in a 5 character limit. So all the text will be pushed to the right hand side. Therefore nothing will be left on screen from the previous iteration. If we try running the application now we will see we're getting the polling, the CPU load, the response time and the user count quite successfully appearing on the screen. So you can see we can quite easily build up information on the screen using only a very few console commands. So in summary what we've done today is we've used console commands to set up a console of a fixed size, make it a virtual screen to allow us to increase it should we wish to do so. We have prepared our screen, used the clear screen command to clear the screen. We have created a function to display static headers and we've used a loop to display information using a delay on the screen to our user in different colors using a standard, generic print to console command. Which allows us to specify the row and column, the text and the color of the text to display. With these few commands you can use the console compiler to display information to a user quite easily to allow them to monitor some background process. Hopefully you'll find this code useful in your applications but that's it for today. Thank you for watching.
